C51 COMPILER V9.54   MY_GAME                                                               09/28/2015 00:19:32 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MY_GAME
OBJECT MODULE PLACED IN .\Objects\my_game.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\2\my_game.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\my_game.lst) TABS(2) OBJECT(.\Objects\my_game.obj)

line level    source

   1          /*Program to display simple text on Graphics LCD*/
   2          
   3          #include<reg51.h>
   4          #include<intrins.h>
   5          #include<stdlib.h>
   6          #define LCD_data P2
   7          
   8          void LCD_CmdWrite(char cmd);
   9          void Timer_Init();
  10          void ctrloff(); 
  11          void setY(unsigned int y);
  12          void setX(unsigned char x);
  13          void writeAtXY(unsigned char x,unsigned char y, char val);
  14          void sdelay(int delay);
  15          void GLCD_WriteData( char dat,int cs);
  16          void clearAll();
  17          void makeCar();
  18          void makeEnemy();
  19          void moveForward();
  20          void moveRight();
  21          void moveLeft();
  22            
  23          sbit SDA=P0^5;
  24          sbit SCL=P0^6;
  25          sbit rs=P0^0;
  26          sbit rw=P0^1;
  27          sbit en=P0^2;
  28          sbit cs1=P3^0;
  29          sbit cs2=P3^1;
  30          int xVal=500,yVal=0,random=500,height_level=0,speed_level=8;
  31          unsigned char data2;
  32          unsigned char data1;
  33          unsigned char count1=0,count2=0;
  34          
  35          int cX,cY,eX,eY;
  36          
  37          void I2CInit()
  38          {
  39   1        SDA = 1;
  40   1        SCL = 1;
  41   1      }
  42           
  43          void I2CStart()
  44          {
  45   1        SDA = 0;
  46   1        SCL = 0;
  47   1      }
  48           
  49          void I2CRestart()
  50          {
  51   1        SDA = 1;
  52   1        SCL = 1;
  53   1        SDA = 0;
  54   1        SCL = 0;
C51 COMPILER V9.54   MY_GAME                                                               09/28/2015 00:19:32 PAGE 2   

  55   1      }
  56           
  57          void I2CStop()
  58          {
  59   1        SCL = 0;
  60   1        SDA = 0;
  61   1        SCL = 1;
  62   1        SDA = 1;
  63   1      }
  64           
  65          void I2CAck()
  66          {
  67   1        SDA = 0;
  68   1        SCL = 1;
  69   1        SCL = 0;
  70   1        SDA = 1;
  71   1      }
  72           
  73          void I2CNak()
  74          {
  75   1        SDA = 1;
  76   1        SCL = 1;
  77   1        SCL = 0;
  78   1        SDA = 1;
  79   1      }
  80           
  81          unsigned char I2CSend(unsigned char Data)
  82          {
  83   1         unsigned char i, ack_bit;
  84   1         for (i = 0; i < 8; i++) {
  85   2          if ((Data & 0x80) == 0)
  86   2            SDA = 0;
  87   2          else
  88   2            SDA = 1;
  89   2          SCL = 1;
  90   2          SCL = 0;
  91   2          Data<<=1;
  92   2         }
  93   1         SDA = 1;
  94   1         SCL = 1;
  95   1         ack_bit = SDA;
  96   1         SCL = 0;
  97   1         return ack_bit;
  98   1      }
  99           
 100          unsigned char I2CRead()
 101          {
 102   1        unsigned char i, Data=0;
 103   1        for (i = 0; i < 8; i++) {
 104   2          SCL = 1;
 105   2          if(SDA)
 106   2            Data |=1;
 107   2          if(i<7)
 108   2            Data<<=1;
 109   2          SCL = 0;
 110   2        }
 111   1        return Data;
 112   1      }
 113          int u(int n){
 114   1        if(n>=0)return n;
 115   1        else return 0;
 116   1      }
C51 COMPILER V9.54   MY_GAME                                                               09/28/2015 00:19:32 PAGE 3   

 117          void I2Cinitialize(){
 118   1        I2CInit();
 119   1        I2CStart();
 120   1        I2CSend(0xA6);
 121   1        I2CSend(0x31);
 122   1        I2CSend(0x01);
 123   1        I2CStop();
 124   1        I2CStart();
 125   1        I2CSend(0xA6);
 126   1        I2CSend(0x2D);
 127   1        I2CSend(0x08);
 128   1        /*
 129   1         * ack == 1 => NAK
 130   1         * ack == 0 => ACK
 131   1         */
 132   1      
 133   1        I2CStop();
 134   1       I2CInit();
 135   1      }
 136          
 137          void main(){
 138   1        //CODE IS WORKING FINE
 139   1        P0 |=0x01;
 140   1        P0 &=0xEF;
 141   1        
 142   1        P1=0xff;
 143   1        height_level= P1 & 0x0f;
 144   1        I2Cinitialize();
 145   1        clearAll();
 146   1        makeCar();
 147   1        makeEnemy();
 148   1        Timer_Init();
 149   1        while(1){
 150   2          //write code here
 151   2          if(count2>1+u(5-abs(xVal-500)/15)){
 152   3            count2=0;
 153   3            I2CStart();
 154   3            I2CSend(0xA6);
 155   3            I2CSend(0xB2);
 156   3            I2CRestart();
 157   3            I2CSend(0xA7);
 158   3            data1 = I2CRead();
 159   3            I2CAck();
 160   3            data2 = I2CRead();
 161   3            xVal = (data2 <<8) + (data1);
 162   3            I2CAck();
 163   3            data1 = I2CRead();
 164   3            I2CAck();
 165   3            data2 = I2CRead();
 166   3            I2CNak();
 167   3            I2CStop();
 168   3            yVal = (data2 <<8) + (data1);
 169   3            xVal = xVal+500;
 170   3            random=xVal*cX;
 171   3            //random=6(atan(double(xVal%7-cX)) +3.14/2)/3.14;
 172   3            if(xVal>510 & cX<6){
 173   4              moveRight();
 174   4            }
 175   3            else if(xVal<490 & cX>0){
 176   4              moveLeft();
 177   4            }
 178   3          }
C51 COMPILER V9.54   MY_GAME                                                               09/28/2015 00:19:32 PAGE 4   

 179   2        } 
 180   1      }
 181          
 182          void makeCar(){
 183   1        int i,j;
 184   1        cX=0,cY=0;
 185   1        for(i=cX;i<cX+2;i++){
 186   2          for(j=0;j<16;j++){
 187   3            writeAtXY(i,j,0xff);
 188   3          }
 189   2        }
 190   1      }
 191          
 192          void makeEnemy(){
 193   1        int i,j;
 194   1        eX=random%7;
 195   1        eY=32+5*(16-height_level);
 196   1        for(i=eX;i<eX+2;i++){
 197   2          for(j=eY;j<eY+16;j++){
 198   3            writeAtXY(i,j,0xff);
 199   3          }
 200   2        }
 201   1      }
 202          
 203          void moveForward(){
 204   1        int i;
 205   1        for(i=eX;i<eX+2;i++){
 206   2            if(16+eY<128 & 16+eY>=0)writeAtXY(i,16+eY,0x00);
 207   2            if(eY<128 & eY>=0)writeAtXY(i,eY,0xff);
 208   2        }
 209   1        eY--;
 210   1      }
 211          
 212          void moveLeft(){
 213   1        int j;
 214   1        cX--;
 215   1        for(j=0;j<16;j++){
 216   2            writeAtXY(cX,j,0xff);
 217   2            writeAtXY(cX+2,j,0x00);
 218   2        }
 219   1      }
 220          
 221          void moveRight(){
 222   1        int j;
 223   1        for(j=0;j<16;j++){
 224   2            writeAtXY(cX,j,0x00);
 225   2            writeAtXY(cX+2,j,0xff);
 226   2        }
 227   1        cX++;
 228   1      }
 229          void clearAll(){
 230   1        int i,j;
 231   1        LCD_CmdWrite(0x3f);
 232   1        for ( i = 0 ; i < 8; i++ ){
 233   2          for(j = 0 ; j < 128; j++ ){
 234   3            writeAtXY(i,j,0x00);
 235   3          }
 236   2        }
 237   1      }
 238          /**
 239          writeAtXY()
 240          This function takes 3input
C51 COMPILER V9.54   MY_GAME                                                               09/28/2015 00:19:32 PAGE 5   

 241          1. X value [0,7]
 242          2. Y value [0,127]
 243          3. val which can be 0xff/0x00
 244          4. Effectively this function goes to (x,y) and turn it on/off.
 245          */
 246          void writeAtXY(unsigned char x,unsigned char y, char val){
 247   1        int p=y%128;
 248   1        setX(x);
 249   1        setY(y);
 250   1        GLCD_WriteData(val,p);
 251   1      }
 252          
 253          //------------------------------------------------------------------------------
 254          //This module set X-axis
 255          // Note: X takes value from 0 to 7
 256          // then set Y-axis accordingly
 257          // Note: Y takes value from 0 to 127
 258          //After this call GLCD_WriteData( char dat,int cs)
 259          
 260          void setX(unsigned char x)  
 261          {
 262   1        LCD_data= 0xb8|x; 
 263   1        LCD_CmdWrite(LCD_data);
 264   1      }
 265          void setY(unsigned int y) 
 266          { 
 267   1        y=y%64;
 268   1        LCD_data= (0x40 | y );   
 269   1        LCD_CmdWrite(LCD_data);
 270   1      }
 271          //--------------------------------------------------------------------------------------------------------
             ---------------
 272          
 273          void LCD_CmdWrite(char cmd){
 274   1        ctrloff();
 275   1        LCD_data=cmd;           
 276   1        rs=0;rw=0;                
 277   1        cs1=cs2=1;
 278   1        en=1;               
 279   1        sdelay(1);
 280   1        en=0;
 281   1        sdelay(1);
 282   1      }
 283          
 284          void GLCD_WriteData( char dat,int cs){
 285   1        ctrloff();
 286   1        LCD_data=dat;         
 287   1        rs=1;rw=0;                
 288   1        en=1;               
 289   1        if(cs<64){  cs1=1;cs2=0;  }
 290   1        else{ cs1=0;cs2=1;  }
 291   1        sdelay(1);
 292   1        en=0;
 293   1        sdelay(1);
 294   1      }
 295          
 296          void sdelay(int delay){
 297   1        //int d=0;
 298   1        while(delay>0){
 299   2          //for(d=0;d<1;d++);
 300   2          delay--;
 301   2        }
C51 COMPILER V9.54   MY_GAME                                                               09/28/2015 00:19:32 PAGE 6   

 302   1      }
 303          
 304          void ctrloff(){
 305   1        rs=0;
 306   1        rw=0;
 307   1        en=0;
 308   1        cs1=0;
 309   1        cs2=0;
 310   1      }
 311          void timer0_ISR (void) interrupt 1
 312          {
 313   1        TH0 = 0xC0;                     //For 25ms operation
 314   1        TL0 = 0x00;
 315   1        P1=0xff;
 316   1        height_level= P1 & 0x0f;
 317   1        if(eY<16 & eY+16>=0 & cX < eX+2 & cX > eX-2){}
 318   1        else{
 319   2          if(count1>=u(8-yVal/10)){
 320   3            count1=0;
 321   3            if(16+eY==0){
 322   4              moveForward();
 323   4              eY=47+5*(16-height_level);
 324   4              eX=random%7;
 325   4            }
 326   3            else moveForward();
 327   3          }
 328   2          count1++;
 329   2          count2++;
 330   2        }
 331   1      }
 332          
 333          
 334          void Timer_Init()
 335          {
 336   1        // Set Timer0 to work in up counting 16 bit mode. Counts upto 
 337   1        // 65536 depending upon the calues of TH0 and TL0
 338   1        // The timer counts 65536 processor cycles. A processor cycle is 
 339   1        // 12 clocks. FOr 24 MHz, it takes 65536/2 uS to overflow
 340   1        // By setting TH0TL0 to 3CB0H, the timer overflows every 25 ms
 341   1        
 342   1        TH0 = 0xC0;                     //For 25ms operation
 343   1        TL0 = 0x00;
 344   1        TMOD = (TMOD & 0xF0) | 0x01;    // Set T/C0 Mode 
 345   1        EA=1;                           
 346   1        ET0 = 1;                        // Enable Timer 0 Interrupts 
 347   1        TR0 = 1;                        // Start Timer 0 Running 
 348   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1458    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
